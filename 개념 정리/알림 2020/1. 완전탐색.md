## 1. 완전탐색 

### 구현

- 완전탐색
- 시뮬레이션

<br>

### 완전탐색 = 브루트 포스(Brute-force search)

- **답이 될 수 있는 모든 경우의 수를 탐색**
  - 시간복잡도는 답이 될 수 있는 경우의 수에 비례
- 가장 쉽고 단순
  - 어려운 문제도 많음.. 요즘 코테에서 자주 나옴

- 자료구조, 알고리즘을 이용해 문제를 효율적으로 최적화하는 과정이 없다면?
  - 구현(=완전탐색, 시뮬레이션)
- 완전탐색으로 먼저 풀이를 생각하다가, 더 효율적인 방법(자료구조, 알고리즘)을 사용하는 방향으로 풀기
- 그래프에서의 완전 탐색 : BFS(너비우선탐색), DFS(깊이우선탐색)

<br>

### 시간 제한

- 10^8룰
  - **컴퓨터는 1초에 약 10^8(1억)번의 연산 수행 가능**

- 시간복잡도 O(n)
  - 입력크기가 n일 때, 전체 연산의 횟수
  - '최악의 경우'의 연산횟수를 고려
- 문제에서 주어진 제한시간, 입력크기를 보고 내가 생각한 풀이가 제한시간안에 가능할지 예측해야 함

<br>

### 메모리 제한

- int형 하나는 4바이트, long long형 하나는 8바이트. 따라서 int형 10^8개가 들어간 배열 = 400MB.

  이런 식으로 예상 가능

- 메모리제한은 보통 넉넉하게 주지만, 그래도 고려해야 함

<br><br>

## 2. 배열/스택/큐/덱

- 배열, 스택, 큐, 덱은 라이브러리에 다 구현되어 있음 
  - 구현보다 활용이 중요
  - 예외 : 삼성 역량 테스트 B, C형 - 라이브러리 사용 못하게 함

<br>

- 스택 
  - top(), push(), pop(), empty()
  - top을 제외한 요소들은 조회가 안됨. 직접 다 pop해서 꺼내봐야 함.

- 큐
  - front(), back(), push(), pop(), empty()
  - front, back을 제외한 요소들은 조회가 안됨. 직접 다 pop해서 꺼내봐야 함.

- 덱 
  - 스택+큐를 합친 구조. 양쪽에서 push, pop이 가능

<img width="430" alt="스택 큐 덱" src="https://user-images.githubusercontent.com/43772750/103561155-5f264200-4efc-11eb-84fb-67bb24f48752.PNG">

<br><br>

---

**문기님의 꿀팁**

- 간단하게 풀리는건 그냥 간단하게 먼저 풀어라! 괜히 어렵게 풀려다가 틀림(내 얘기)
- 문자열 문제풀때는 무조건 string 쓰기

