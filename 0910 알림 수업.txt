연결리스트를 이용한 분리집합의 처리
: 어떤 원소가 어떤 집합에 포함되어있는지(find(x))는 쉽게 알 수있음
  대신 합집합 연산(union)을 할때 원소 하나하나를 옮겨야하기 때문에 복잡도 오짐
  (원소의 포인터 하나하나를 옮겨줘야함)
  구현이 복잡함
  ->안쓰니까 그냥 몰라도됨

트리를 이용한 분리집합의 처리
: 자식노드가 부모노드를 가리키는 트리
  (자식노드의 화살표를 따라가면 어떤 집합에 속하는지 알 수 있을것-부모노드 타고 올라가니깐)

Make(x)
: 자기 자신을 가리키도록 함(부모를 가리켜야 하는데 부모가 없으니!)
  p[1] = 1; p[2] = 2; ...

Find(x)
: 부모노드를 타고 올라가서 루트노드를 찾음
  p[3] = 2; //3의 부모노드는 2
  p[2] = 1; //2의 부모노드는 1
  p[1] = 1; //1의 부모노드는 1 -> 1은 루트노드

Union(x, y)
: 하나의 루트노드가 다른 집합의 루트노드를 가리키도록
  -> 두 집합이 합쳐짐

트리를 이용한 분리집합처리의 문제점: 트리에 편향이 생김!
 -> 특히 find연산에서! 편향된 상태에서 노드수가 너무 많으면 너무 오래걸림
 => 해결 1. 경로압축 2. rank : 하나만 써도 ㄱㅊ고, 둘다 쓰면 ㅈㄴ 빠름

경로압축(29페이지) -> find 연산에 적용:
p[a] = f //a의 루트노드는 f임을 저장하고!
return f //a의 루트노드 리턴
->a의 루트노드가 f임을 바로! 알 수 있다

rank -> union 연산에 적용:
자신을 루트로 하는 서브트리의 (최대)높이= rank

그래프의 연결요소는 분리집합 (하나의 노드가 두개의 그래프에 포함될 수는 없으니)
->연결요소를 구할때 union-find를 쓸 수 있다

백준 4195번은 c++의 경우 문자열 해싱을 해야함(모르면 슬랙에서 물어보기)

