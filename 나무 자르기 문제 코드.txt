//나무 자르기
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <algorithm>

using namespace std;

int arr[1000000]; //각 나무 길이 
				  //이 배열을 main함수의 지역변수로 선언하면 배열이 너무 커서인지 안돌아감! 근데 전역변수로 하면 돌아감 -> 스택 용량이 작아서 그런가?

int cnt, take; //나무개수, 가져갈 나무 총 길이
			   // #include <algorithm> 쓸 때 count변수는 이미 지정된 변수 -> count 내가 직접 정의 불가

bool checkH(int h)
{
	int wood, sum; //가져갈 나무 길이, 가져갈 나무 길이의 합
	sum = 0;
	for (int i = 0; i < cnt; i++) {
		if (arr[i] > h)
			wood = arr[i] - h;
		else wood = 0;
		sum += wood;
	}

	if (sum >= take)
		return true;
	else return false;
}

int main()
{
	int left, right, mid; //h 최대 찾기
	int max = 0; //나무 최대 길이

	scanf("%d %d", &cnt, &take);
	for (int i = 0; i < cnt; i++) {
		scanf("%d", arr+i);
		max = std::max(max, arr[i]);
	}

	left = 1;
	right = max-1;
	mid = (left + right) / 2;

	while (left + 1 < right)
	{
		if (checkH(mid) == true)
		{
			left = mid;
			mid = (left + right) / 2;
		}
		else
		{
			right = mid;
			mid = (left + right) / 2;
		}
	}

	if (max < left)
		cout << max;
	else cout << left;

}


// 예산 배정 문제 코드
#include <iostream>
#include <stdlib.h>

using namespace std;

int getSum(int max, int req[], int count) //사용한 총 예산
{
	int sum = 0;
	for (int i = 0; i < count; i++) {
		if (req[i] > max)
			sum += max;
		else sum += req[i];
	}
	return sum;
}


int main()
{
	int count, req[10000], money; //지방의 수, 각 지방의 예산 요청, 총 예산
	int max = 0; //배정된 예산 중 최댓값

	scanf("%d", &count);
	for (int i = 0; i < count; i++) {
		scanf("%d", &req[i]);
		if (max < req[i])
			max = req[i];
	}
	scanf("%d", &money);


	int left = 1, right = 100000;
	int mid = (left + right) / 2;

	while (left + 1 < right)
	{
		if (getSum(mid, req, count) > money) {
			right = mid;
			mid = (left + right) / 2;
		}
		else
		{
			left = mid;
			mid = (left + right) / 2;
		}
	} //left는 최대 상한값

	if (max > left)
		printf("%d", left);
	else printf("%d", max);
}







//랜선자르기
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <algorithm>


using namespace std;

typedef long long Long;

//이렇게 전역변수로 두면 함수에서 참조하기 편하다
int given_cnt, need_cnt; //영식이의 랜선 개수, 최소 필요한 랜선 개수 (Long이든 int든 상관없음. 주어진 범위가 int형 안에 들어가기 때문에..)
Long arr[10000]; //영식이의 각 랜선 길이

int getCount(Long get_len) //자를 랜선길이, 영식이의 각 랜선 길이, 영식이의 랜선 개수
{
	int count=0;
	for (int i = 0; i < given_cnt; i++) {
		count += (arr[i] / get_len);
	}
	return count;
} //자른 랜선 개수 총합

int main(void)
{
	Long max_len = 0; //영식이의 랜선 길이 중 최대
	scanf("%d %d", &given_cnt, &need_cnt);

	for (int i = 0; i < given_cnt; i++) {
		scanf("%lld", arr+i); // &arr[i] 도 상관없음. long long을 scanf로 받을 때는 %lld로 받아야함
		//if (max_len < arr[i])
			//max_len = arr[i];
		max_len = std::max(max_len, arr[i]); //위 주석을 대신하는 라이브러리 함수
	}

	Long left = 1, right = max_len +1; //이 +1이 문제였다.. 이거 안하면 틀림. 왜그러지? **질문**
	Long mid = (left + right) / 2;

	while (left + 1 < right) {

		if (getCount(mid) >= need_cnt) {
			left = mid;
			mid = (left + right) / 2;
		}
		else {
			right = mid;
			mid = (left + right) / 2;
		}
	}

	printf("%lld", left);
}


//2110번 공유기 설치
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <algorithm>

using namespace std;
typedef long long Long;
Long house[200000]; //집 좌표가 순서대로 저장된 배열
int my_house; // 집 개수
int my_wifi; // 공유기 개수

bool possibleD(Long d)
{
	int start = 0;
	int wifi_cnt = my_wifi - 1; //남은 공유기 개수

	for (int i = 1; i < my_house; i++)
	{
		if (house[i] - house[start] >= d)
		{
			start = i;
			wifi_cnt--;
		}
		if (wifi_cnt == 0)
			return true;
	}
	return false;
}

int main(void)
{
	scanf("%d %d", &my_house, &my_wifi);
	for (int i = 0; i < my_house; i++) {
		cin >> house[i];
	}

	sort(house, house + my_house); //sort(배열 시작주소, 시작주소+(정렬할 끝index+1));
	Long left = 1, right = house[my_house - 1];
	Long mid = (left + right) / 2;

	while (left + 1 < right)
	{
		if (possibleD(mid) == true) {
			left = mid;
			mid = (left + right) / 2;
		}
		else {
			right = mid;
			mid = (left + right) / 2;
		}
	}
	cout << left;
}

//k번째 수
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <algorithm>

using namespace std;
typedef long long Long;

int N; //배열 크기
Long k;


int main(void)
{
	cin >> N;
	cin >> k;

	Long now = 1;
	int cnt = 1;
	
	for (int i = 1; i <= N; i++) {
			// 이 수들 중 now가 있는지 이분탐색으로 확인
			Long left = i, right = i * N;
			Long mid = (left + right) / 2;

			while (left + 1 < right) {
				if (mid <= now) {
					left = mid;
					mid = (left + right) / 2;
				}
				else {
					right = mid;
					mid = (left + right) / 2;
				}
			}
			if (left == now) {
				cnt++;
				now++;
			}

			if (cnt == k)
				cout << now;
	}
}